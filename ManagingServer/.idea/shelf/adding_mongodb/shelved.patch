Index: recommendation_engine/movie_recommender.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import csv\r\nimport pandas as pd\r\nimport numpy as np\r\n\r\nclass MovieRecommender:\r\n    def __init__(self, ratings, movie_data, k=35):\r\n        self.movie_data = movie_data\r\n        self.ratings = ratings\r\n        self.k = k\r\n\r\n    def recommend_algo(self, user_i, ratedMovies, moviesRatings):\r\n        # Remove duplicated ratings for userId. (Movies that are rerated) \r\n       \r\n        recommendResults = []\r\n\r\n        for singleRateVector in moviesRatings:\r\n            delete_rows_by_user_and_movies(user_id=user_i, movie_ids=ratedMovies, csv_file_path='data/smallest-ratings.csv')\r\n            save_to_csv(user_id=user_i, movie_ids=ratedMovies, ratings=singleRateVector, csv_file_path='data/smallest-ratings.csv')\r\n            self.ratings = pd.read_csv('data/smallest-ratings.csv')\r\n\r\n            # Create a user-item matrix (user ratings)\r\n            user_item_matrix = self.ratings.pivot_table(index='userId', columns='movieId', values='rating').fillna(0)\r\n            matrix = user_item_matrix.values\r\n            \r\n            # Define the maximum rate\r\n            max_rate = 10\r\n\r\n            # Calculate the average of the range [1, 10]\r\n            average = np.mean(np.arange(1, max_rate))\r\n\r\n            NormalizedMatrix = matrix - average\r\n\r\n            # Mask the normalized matrix where -average is replaced with 0\r\n            masked_matrix = np.where(NormalizedMatrix == -average, 0, NormalizedMatrix)\r\n            user_row = masked_matrix[user_i]\r\n\r\n            # Compute the dot product of the first row with each subsequent row\r\n            dot_products = [np.dot(user_row, row) for i, row in enumerate(masked_matrix) if i != user_i]\r\n\r\n            # Count identical non-zero indices between the first row and each subsequent row\r\n            count_rated_indices = [np.sum((user_row != 0) & (row != 0)) for i, row in enumerate(masked_matrix) if i != user_i]\r\n\r\n            # Calculate correlation (dot product normalized by count of identical indices)\r\n            dot_products_array = np.array(dot_products)\r\n            count_rated_indices_array = np.array(count_rated_indices)\r\n            correlation = np.where(count_rated_indices_array != 0, (dot_products_array / count_rated_indices_array) / 10, 0)\r\n\r\n            fix_corr_array = (correlation + average)\r\n            original_user_row = matrix[user_i]\r\n\r\n            # Assuming 'original_matrix' and 'fix_corr_array' are defined as before\r\n\r\n            # Identify indices in 'original_first_row' where elements are 0\r\n            zero_indices = np.where(original_user_row == 0)[0]\r\n\r\n            # Create a new matrix to store the results\r\n            new_matrix = np.zeros_like(matrix)\r\n\r\n            # Loop through each zero index and perform the calculations\r\n            for zero_index in zero_indices:\r\n                for line_index in range(1, matrix.shape[0]):\r\n                    # Compute the rounded value based on the formula\r\n                    rounded_value = np.round(matrix[line_index][zero_index] * fix_corr_array[line_index - 1] / 10)\r\n                    \r\n                    # Update the corresponding position in the new matrix\r\n                    new_matrix[line_index][zero_index] = rounded_value\r\n\r\n            num_columns = new_matrix.shape[1]\r\n            # Dictionary to store column index and average value\r\n            column_avg_dict = {}\r\n\r\n            for column_index in range(num_columns):\r\n                # Access elements in the current column\r\n                current_column = new_matrix[:, column_index]\r\n\r\n                # Your code for processing the current column goes here\r\n                # For example, you can calculate the average excluding zero values:\r\n                non_zero_values = current_column[current_column != 0]\r\n                average_value = np.mean(non_zero_values) if non_zero_values.size > 0 else 0\r\n\r\n                # Save the results in the dictionary\r\n                column_avg_dict[self.movie_data.iloc[column_index]['title']] = average_value\r\n\r\n            recommendResults.append(column_avg_dict)\r\n        \r\n        return recommendResults\r\n\r\n\r\n\r\ndef save_to_csv(user_id, movie_ids, ratings, csv_file_path):\r\n    \"\"\"\r\n    Save user_id, movie_id, and rating to the specified CSV file.\r\n    \r\n    Args:\r\n    - user_id (int or str): User ID.\r\n    - movie_id (int or str): Movie ID.\r\n    - rating (float or str): Rating.\r\n    - csv_file_path (str): Path to the CSV file.\r\n    \"\"\"\r\n    # Open the CSV file in append mode\r\n    with open(csv_file_path, 'a', newline='') as file:\r\n        # Create a csv.writer object\r\n        csv_writer = csv.writer(file)\r\n        \r\n        # Iterate over movie_ids and ratings, and write each pair to the CSV file\r\n        for movie_id, rating in zip(movie_ids, ratings):\r\n            csv_writer.writerow([user_id, movie_id, rating])\r\n\r\ndef delete_rows_by_user_and_movies(user_id, movie_ids, csv_file_path):\r\n    \"\"\"\r\n    Delete rows from the CSV file that match the given user_id and any of the movie_ids.\r\n    \r\n    Args:\r\n    - user_id (str or int): User ID to filter by.\r\n    - movie_ids (list): List of movie IDs to filter by.\r\n    - csv_file_path (str): Path to the CSV file.\r\n    \"\"\"\r\n    # Convert user_id to string for comparison\r\n    user_id = str(user_id)\r\n    \r\n    # Convert movie_ids to strings for comparison\r\n    movie_ids = [str(mid) for mid in movie_ids]\r\n    \r\n    # Read existing CSV file and filter rows\r\n    rows_to_keep = []\r\n    with open(csv_file_path, 'r') as file:\r\n        csv_reader = csv.reader(file)\r\n        for row in csv_reader:\r\n            if row[0] != user_id or row[1] not in movie_ids:\r\n                rows_to_keep.append(row)\r\n    \r\n    # Write the filtered rows back to the CSV file\r\n    with open(csv_file_path, 'w', newline='') as file:\r\n        csv_writer = csv.writer(file)\r\n        csv_writer.writerows(rows_to_keep)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/recommendation_engine/movie_recommender.py b/recommendation_engine/movie_recommender.py
--- a/recommendation_engine/movie_recommender.py	(revision a2cc81fe648e4a3cfd234d241c2b066f3baa031d)
+++ b/recommendation_engine/movie_recommender.py	(date 1732634524258)
@@ -16,7 +16,7 @@
         for singleRateVector in moviesRatings:
             delete_rows_by_user_and_movies(user_id=user_i, movie_ids=ratedMovies, csv_file_path='data/smallest-ratings.csv')
             save_to_csv(user_id=user_i, movie_ids=ratedMovies, ratings=singleRateVector, csv_file_path='data/smallest-ratings.csv')
-            self.ratings = pd.read_csv('data/smallest-ratings.csv')
+            # self.ratings = pd.read_csv('data/smallest-ratings.csv')
 
             # Create a user-item matrix (user ratings)
             user_item_matrix = self.ratings.pivot_table(index='userId', columns='movieId', values='rating').fillna(0)
Index: server/app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pandas as pd\r\nfrom flask import Flask, request, jsonify\r\nfrom flask_cors import CORS\r\nfrom recommendation_engine.movie_recommender import MovieRecommender\r\nimport logging\r\nfrom threading import Lock\r\n\r\napp = Flask(__name__)\r\nCORS(app)\r\n\r\n# Load the movie dataset into a DataFrame\r\nmovie_data = pd.read_csv('data/small-movies.csv')\r\n\r\n# Load the user ratings dataset into a DataFrame\r\nratings_data = pd.read_csv('data/smallest-ratings.csv')\r\n\r\n# Define a lock for handling recommendations\r\nrecommendation_lock = Lock()\r\n\r\n@app.route('/recommend', methods=['GET'])\r\ndef get_recommendations():\r\n    user_id = request.args.get('userId')\r\n    \r\n    if user_id:\r\n        user_i = int(user_id)\r\n        \r\n        with recommendation_lock:\r\n            recommender = MovieRecommender(ratings=ratings_data, movie_data=movie_data)\r\n            recommended_movies = recommender.recommend_movies(user_i=user_i, num_recommendations=5)\r\n            \r\n        return jsonify(recommended_movies)\r\n    else:\r\n        return 'Error: Please provide a valid user ID in the request parameters.'\r\n\r\n@app.route('/get_recommendations', methods=['POST'])\r\ndef get_recommendations_grades():\r\n    try:\r\n        data = request.json\r\n        movies = data.get('movies', [])\r\n        ratings = data.get('ratings', [])\r\n        userId = data.get('userId', None)\r\n        \r\n        if userId is not None:\r\n            userId = int(userId)\r\n        \r\n        if not movies or not ratings:\r\n            return jsonify({\"error\": \"Both movies and ratings arrays must be provided\"}), 400\r\n        \r\n        with recommendation_lock:\r\n            recommender = MovieRecommender(ratings=ratings_data, movie_data=movie_data)\r\n            response_data = recommender.recommend_algo(user_i=userId, ratedMovies=movies, moviesRatings=ratings)\r\n            \r\n        if isinstance(response_data, list):\r\n            print('valid')\r\n            return jsonify(response_data), 200\r\n        else:\r\n            print('error')\r\n            return jsonify({\"error\": response_data}), 400\r\n    \r\n    except Exception as e:\r\n        logging.error(f\"Exception occurred: {str(e)}\")\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\n@app.route('/get_titles', methods=['POST'])\r\ndef get_titlescls():\r\n    try:\r\n        data = request.json\r\n        movies = data.get('movies', [])\r\n              \r\n        with recommendation_lock:\r\n            response_data = movie_data.iloc[movies]['title'].tolist()\r\n            \r\n        if isinstance(response_data, list):\r\n            return jsonify(response_data), 200\r\n        else:\r\n            print('error')\r\n            return jsonify({\"error\": response_data}), 400\r\n    \r\n    except Exception as e:\r\n        logging.error(f\"Exception occurred: {str(e)}\")\r\n        return jsonify({\"error\": str(e)}), 500\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True, threaded=False)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server/app.py b/server/app.py
--- a/server/app.py	(revision a2cc81fe648e4a3cfd234d241c2b066f3baa031d)
+++ b/server/app.py	(date 1732634524238)
@@ -4,81 +4,125 @@
 from recommendation_engine.movie_recommender import MovieRecommender
 import logging
 from threading import Lock
+from pymongo import MongoClient
 
 app = Flask(__name__)
 CORS(app)
+client = MongoClient("mongodb+srv://davideli914:de123456@cluster0.kt5fo.mongodb.net/")
+db = client["privateMovie"]
+users_collections = db["users"]
+ratings_collection = db["ratings"]
 
 # Load the movie dataset into a DataFrame
 movie_data = pd.read_csv('data/small-movies.csv')
 
 # Load the user ratings dataset into a DataFrame
-ratings_data = pd.read_csv('data/smallest-ratings.csv')
+ratings_data = ratings_collection.find()
 
 # Define a lock for handling recommendations
 recommendation_lock = Lock()
+print(ratings_data)
+
+
+@app.route('/signUp', methods=['POST'])
+def sign_up():
+    data = request.json
+    user_name = data.get('username')
+    document = users_collections.find_one({"username": user_name})
+
+    if document:
+        return "There is already such a user", 500
+    users_collections.insert_one(data)
+    return jsonify(True), 200
 
+
+@app.route('/signIn', methods=['POST'])
+def sign_in():
+    data = request.json
+    user_name = data.get('username')
+    password = data.get('password')
+    document = users_collections.find_one({"username": user_name, "password": password})
+    if document:
+        return jsonify(True), 200
+    return "username or password are incorrect", 401
 @app.route('/recommend', methods=['GET'])
 def get_recommendations():
     user_id = request.args.get('userId')
-    
+
     if user_id:
         user_i = int(user_id)
-        
+
         with recommendation_lock:
             recommender = MovieRecommender(ratings=ratings_data, movie_data=movie_data)
             recommended_movies = recommender.recommend_movies(user_i=user_i, num_recommendations=5)
-            
+
         return jsonify(recommended_movies)
     else:
         return 'Error: Please provide a valid user ID in the request parameters.'
 
+
 @app.route('/get_recommendations', methods=['POST'])
 def get_recommendations_grades():
     try:
         data = request.json
         movies = data.get('movies', [])
         ratings = data.get('ratings', [])
-        userId = data.get('userId', None)
-        
-        if userId is not None:
-            userId = int(userId)
-        
+        user = data.get('user', None)
+
+        if user is not None:
+            user = hash(user)
+
         if not movies or not ratings:
             return jsonify({"error": "Both movies and ratings arrays must be provided"}), 400
-        
+
+#TODO: ratings data is now a mongodb cursor, update the algo to match that, find out what is the ratings argument of the request
         with recommendation_lock:
             recommender = MovieRecommender(ratings=ratings_data, movie_data=movie_data)
-            response_data = recommender.recommend_algo(user_i=userId, ratedMovies=movies, moviesRatings=ratings)
-            
+            response_data = recommender.recommend_algo(user_i=user, ratedMovies=movies, moviesRatings=ratings)
+
         if isinstance(response_data, list):
             print('valid')
             return jsonify(response_data), 200
         else:
             print('error')
             return jsonify({"error": response_data}), 400
-    
+
     except Exception as e:
         logging.error(f"Exception occurred: {str(e)}")
         return jsonify({"error": str(e)}), 500
 
+
+@app.route('/rate_movie', methods=['POST'])
+def rate_movie():
+    data = request.json
+    user_name=data.get('username')
+    movie_id = data.get('movieId')
+    rating = data.get('rating')
+    userHash = hash(user_name)
+
+    ratings_collection.insert_one({"user": userHash, "movieId": movie_id, "rating": rating})
+    return jsonify(True), 200
+# @app.route('/get_all_movies', methods=['GET'])
+
 @app.route('/get_titles', methods=['POST'])
 def get_titlescls():
     try:
         data = request.json
         movies = data.get('movies', [])
-              
+
         with recommendation_lock:
             response_data = movie_data.iloc[movies]['title'].tolist()
-            
+
         if isinstance(response_data, list):
             return jsonify(response_data), 200
         else:
             print('error')
             return jsonify({"error": response_data}), 400
-    
+
     except Exception as e:
         logging.error(f"Exception occurred: {str(e)}")
         return jsonify({"error": str(e)}), 500
 
+
 if __name__ == '__main__':
     app.run(debug=True, threaded=False)
